# Лабораторная работа №6 "АТД. Контейнеры."

## Постановка задачи

1. Определить класс-контейнер.
2. Реализовать конструкторы, деструктор, операции ввода-вывода, операцию
присваивания.
3. Перегрузить операции, указанные в варианте.
4. Реализовать класс-итератор. Реализовать с его помощью операции
последовательного доступа.
5. Написать тестирующую программу, иллюстрирующую выполнение операций.

### 7 Вариант:

Класс-контейнер МНОЖЕСТВО с элементами типа int.

Реализовать операции:

- [] – доступа по индексу;
- int() – определение размера вектора;
- * – пересечение множеств;
- -- - переход к предыдущему элементу ( с помощью класса-итератора).

## UML-диаграмма

пока не готова

## Код программы

`plurality.h`
```cpp
#pragma once
using namespace std;
class Iterator
{
	friend class Plurality;
	int* elem;
public:
	Iterator()
	{
		elem = 0;
	}
	Iterator(int* e)
	{
		elem = e;
	}
	Iterator(const Iterator& it)
	{
		elem = it.elem;
	}
	bool operator==(const Iterator& it)
	{
		return elem == it.elem;
	}
	bool operator!=(const Iterator& it)
	{
		return elem != it.elem;
	}
	Iterator operator++();
	Iterator operator--();
	Iterator operator++(int);
	Iterator operator--(int);
	int& operator *() const
	{
		return *elem;
	}
};
class Plurality
{
public:
	Plurality(int s, int k = 0);
	//конструктор с параметрами
	Plurality(const Plurality& a);
	//деструктор
	~Plurality();
	Iterator first()
	{
		return beg;
	}
	Iterator last()
	{
		return end;
	}
	void deleteDubs();
	Plurality& operator=(const Plurality&);
	int operator ()();
	int& operator[](int);
	Plurality operator+(const int);
	Plurality operator*(Plurality&);
	friend ostream& operator<<(ostream& out, Plurality& a);
	friend istream& operator>>(istream& in, Plurality& a);
private:
	int size;
	int* data;
	Iterator beg;
	Iterator end;
};
```

`plurality.cpp`
```cpp
#pragma once
#include <iostream>
#include <vector>
#include "plurality.h"
using namespace std;
Iterator Iterator::operator++()
{
	this->elem++;
	return *this;
}
Iterator Iterator::operator--()
{
	this->elem--;
	return *this;
}
Iterator Iterator::operator++(int)
{
	Iterator result(elem);
	this->elem++;
	return result;
}
Iterator Iterator::operator--(int)
{
	Iterator result(elem);
	this->elem--;
	return result;
}
Plurality::Plurality(int s, int k)
{
	size = s;
	data = new int[size];
	for (int i = 0; i < size; i++) data[i] = k;
	beg.elem = &data[0];
	end.elem = &data[size];
}
//конструктор копирования
Plurality::Plurality(const Plurality& a)
{
	size = a.size;
	data = new int[size];
	for (int i = 0;i < size;i++) data[i] = a.data[i];
	beg = a.beg;
	end = a.end;
}
Plurality::~Plurality()
{
	delete[] data;
	data = 0;
}
void Plurality::deleteDubs()
{
	int newSize = 0;
	vector<int> biloUzhe;
	biloUzhe.push_back(data[0]);
	for (int i = 1; i < size; i++)
	{
		bool yest = false;
		for (int j = 0; j < biloUzhe.size(); j++)
		{
			if (data[i] == biloUzhe[j])
			{
				yest = true;
				break;
			}
		}
		if (!yest) biloUzhe.push_back(data[i]);
	}
	Plurality result(biloUzhe.size());
	for (int i = 0; i < biloUzhe.size(); i++) result[i] = biloUzhe[i];
	*this = result;
	this->beg = &this->data[0];
	this->end = &this->data[biloUzhe.size()];
}
//операция присваивания
Plurality& Plurality::operator=(const Plurality& a)
{
	if (this == &a) return *this;
	size = a.size;
	if (data != 0) delete[] data;
	data = new int[size];
	for (int i = 0;i < size;i++) data[i] = a.data[i];
	beg = a.beg;
	end = a.end;
	return *this;
}
int Plurality::operator()()
{
	return size;
}
int& Plurality::operator[](int index)
{
	if (index < size) return data[index];
	else { cout << "\nОшибка! Индекс больше размера множества."; exit(1); }
}
Plurality Plurality::operator+(const int k)
{
	Plurality temp(size);
	for (int i = 0;i < size;++i)
		temp.data[i] += data[i] + k;
	return temp;
}
Plurality Plurality::operator*(Plurality& p)
{
	Plurality temper(size);
	int newSize = 0;
	int it = 0;
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < p(); j++)
		{
			if (data[i] == p.data[j])
			{
				temper[it++] = data[i];
				newSize++;
				break;
			}
		}
	}
	Plurality temp(newSize);
	for (int i = 0; i < newSize; i++)
	{
		temp[i] = temper[i];
	}
	return temp;
}
ostream& operator<<(ostream& out, Plurality& a)
{
	out << "Вывод множества:" << endl;
	for (int i = 0; i < a(); ++i)
	{
		out << a.data[i] << " ";
	}
	out << endl;
	return out;
}
istream& operator>>(istream& in, Plurality& a)
{
	cout << "Ввод множества: " << endl;
	for (int i = 0; i < a(); ++i)
	{
		cout << "Введите элемент множества: [" << i << "] = ";
		in >> a.data[i];
	}
	cout << endl;
	return in;
}
```

`main.cpp`
```cpp
#include <iostream>
#include "plurality.h"
using namespace std;
int main()
{
	setlocale(LC_ALL, "Russian");
	cout << "Множество из 5 элементов, заполненное нулями:" << endl;
	Plurality a(5);
	cout << a << "\n";
	cin >> a; // ввод элементов множества
	a.deleteDubs(); // удаляет дубликаты из множества
	cout << a << "\n";
	cout << "Введите индекс, и значение для замены. Вводить два числа через пробел. -> ";
	int index, element;
	cin >> index >> element;
	a[index] = element;
	a.deleteDubs();
	cout << "Множество полсе замены:\n";
	cout << a << "\n";
	cout << "Множество из 10 элементов, заполненное нулями:\n";
	Plurality b(10);
	cout << b << "\n";
	b = a;
	cout << "В это множество скопировали первое множество:\n";
	cout << b << "\n";
	Plurality c(10);
	c = b + 100;
	cout << "Увеличели на 100:\n";
	cout << c << "\n";
	cout << "Размер первого множества: " << a() << endl;
	cout << "Первый элемент первого множества: " << *(a.first()) << endl;
	Iterator i = a.first();
	i++;
	cout << "Второй элемент через итератор: " << *i << endl;
	cout << "Первое множество через итератор:\n";
	for (i = a.first(); i != a.last(); i++) cout << *i << endl;
	cout << "Первое множество через итератор, задом наперед:\n";
	for (--(i = a.last()); i != a.first(); i--) cout << *i << endl;
	cout << *i << endl;
	
	Plurality d(15);
	cin >> d;
	d.deleteDubs(); // убирает дубликаты из множества
	c = a * d;
	cout << "Пересечение первого множества с текущим:\n" << c;
	return 0;
}
```

## Тесты текстом

```cpp
/*
0)
Множество из 5 элементов, заполненное нулями:
Вывод множества:
0 0 0 0 0

Ввод множества:
Введите элемент множества: [0] = 1
Введите элемент множества: [1] = 2
Введите элемент множества: [2] = 3
Введите элемент множества: [3] = 4
Введите элемент множества: [4] = 5

Вывод множества:
1 2 3 4 5

Введите индекс, и значение для замены. Вводить два числа через пробел. -> 50 -54

Ошибка! Индекс больше размера множества.


1)
Множество из 5 элементов, заполненное нулями:
Вывод множества:
0 0 0 0 0

Ввод множества:
Введите элемент множества: [0] = 11
Введите элемент множества: [1] = 1
Введите элемент множества: [2] = 11
Введите элемент множества: [3] = 34
Введите элемент множества: [4] = 1

Вывод множества:
11 1 34

Введите индекс, и значение для замены. Вводить два числа через пробел. -> 0 3
Множество полсе замены:
Вывод множества:
3 1 34

Множество из 10 элементов, заполненное нулями:
Вывод множества:
0 0 0 0 0 0 0 0 0 0

В это множество скопировали первое множество:
Вывод множества:
3 1 34

Увеличели на 100:
Вывод множества:
103 101 134

Размер первого множества: 3
Первый элемент первого множества: 3
Второй элемент через итератор: 1
Первое множество через итератор:
3
1
34
Первое множество через итератор, задом наперед:
34
1
3
Ввод множества:
Введите элемент множества: [0] = 34
Введите элемент множества: [1] = 56
Введите элемент множества: [2] = -56
Введите элемент множества: [3] = 3
Введите элемент множества: [4] = 0
Введите элемент множества: [5] = 76
Введите элемент множества: [6] = 0
Введите элемент множества: [7] = 45
Введите элемент множества: [8] = 4
Введите элемент множества: [9] = 4
Введите элемент множества: [10] = 56
Введите элемент множества: [11] = 0
Введите элемент множества: [12] = 12
Введите элемент множества: [13] = -56
Введите элемент множества: [14] = 34

Пересечение первого множества с текущим:
Вывод множества:
3 34


2)
Множество из 5 элементов, заполненное нулями:
Вывод множества:
0 0 0 0 0

Ввод множества:
Введите элемент множества: [0] = 38264528
Введите элемент множества: [1] = 832764
Введите элемент множества: [2] = 23745
Введите элемент множества: [3] = 1
Введите элемент множества: [4] = 1

Вывод множества:
38264528 832764 23745 1

Введите индекс, и значение для замены. Вводить два числа через пробел. -> 1 23745
Множество полсе замены:
Вывод множества:
38264528 23745 1

Множество из 10 элементов, заполненное нулями:
Вывод множества:
0 0 0 0 0 0 0 0 0 0

В это множество скопировали первое множество:
Вывод множества:
38264528 23745 1

Увеличели на 100:
Вывод множества:
38264628 23845 101

Размер первого множества: 3
Первый элемент первого множества: 38264528
Второй элемент через итератор: 23745
Первое множество через итератор:
38264528
23745
1
Первое множество через итератор, задом наперед:
1
23745
38264528
Ввод множества:
Введите элемент множества: [0] = 23745
Введите элемент множества: [1] = 0
Введите элемент множества: [2] = 0
Введите элемент множества: [3] = 1
Введите элемент множества: [4] = -98
Введите элемент множества: [5] = 98
Введите элемент множества: [6] = -98
Введите элемент множества: [7] = 98
Введите элемент множества: [8] = 1
Введите элемент множества: [9] = 0
Введите элемент множества: [10] = 23745
Введите элемент множества: [11] = 1
Введите элемент множества: [12] = 1
Введите элемент множества: [13] = 0
Введите элемент множества: [14] = -67

Пересечение первого множества с текущим:
Вывод множества:
23745 1


3)
Множество из 5 элементов, заполненное нулями:
Вывод множества:
0 0 0 0 0

Ввод множества:
Введите элемент множества: [0] = -99
Введите элемент множества: [1] = 343
Введите элемент множества: [2] = 32
Введите элемент множества: [3] = 1
Введите элемент множества: [4] = 0

Вывод множества:
-99 343 32 1 0

Введите индекс, и значение для замены. Вводить два числа через пробел. -> 2 45
Множество полсе замены:
Вывод множества:
-99 343 45 1 0

Множество из 10 элементов, заполненное нулями:
Вывод множества:
0 0 0 0 0 0 0 0 0 0

В это множество скопировали первое множество:
Вывод множества:
-99 343 45 1 0

Увеличели на 100:
Вывод множества:
1 443 145 101 100

Размер первого множества: 5
Первый элемент первого множества: -99
Второй элемент через итератор: 343
Первое множество через итератор:
-99
343
45
1
0
Первое множество через итератор, задом наперед:
0
1
45
343
-99
Ввод множества:
Введите элемент множества: [0] = 756
Введите элемент множества: [1] = 347
Введите элемент множества: [2] = -99
Введите элемент множества: [3] = -99
Введите элемент множества: [4] = 1
Введите элемент множества: [5] = 0
Введите элемент множества: [6] = 0
Введите элемент множества: [7] = 1
Введите элемент множества: [8] = 2
Введите элемент множества: [9] = -99
Введите элемент множества: [10] = 76
Введите элемент множества: [11] = 45
Введите элемент множества: [12] = 2
Введите элемент множества: [13] = 9876
Введите элемент множества: [14] = 45564

Пересечение первого множества с текущим:
Вывод множества:
-99 45 1 0

*/
```

## Тесты скриншоты
![Скриншот номер 0](https://github.com/Fedor0000/TheUltimateFolder/blob/main/Sem_2/Labs/class/Lab6/screen/0.png)
![Скриншот номер 1](https://github.com/Fedor0000/TheUltimateFolder/blob/main/Sem_2/Labs/class/Lab6/screen/1.png)
![Скриншот номер 2](https://github.com/Fedor0000/TheUltimateFolder/blob/main/Sem_2/Labs/class/Lab6/screen/2.png)
![Скриншот номер 3](https://github.com/Fedor0000/TheUltimateFolder/blob/main/Sem_2/Labs/class/Lab6/screen/3.png)

## Ответы на вопросы

**1. Что такое абстрактный тип данных? Привести примеры АТД.**

`Абстрактный тип данных (АТД) - это математическая модель для типов данных, где тип данных определяется его поведением (семантикой) с точки зрения пользователя данных, в терминах возможных значений, возможных операций над данными этого типа и поведения этих операций. Примеры АТД: стек, очередь, список, множество.`

**2. Привести примеры абстракции через параметризацию.**

`Абстракция через параметризацию позволяет определить структуру, которая может работать с любым типом данных. Примером может служить шаблон класса, где тип данных, с которым должен работать класс, является параметром.`

**3. Привести примеры абстракции через спецификацию.**

`Абстракция через спецификацию включает определение общего интерфейса, который может быть реализован различными способами. Например, интерфейс списка, который может быть реализован как связный список или массив.`

**4. Что такое контейнер? Привести примеры.**

`Контейнер в программировании - это тип, позволяющий инкапсулировать в себе объекты других типов. Примеры контейнеров: vector, list, map.`

**5. Какие группы операций выделяют в контейнерах?**

`В контейнерах выделяют группы операций для добавления, удаления и доступа к элементам, а также операции для работы с размером и состоянием контейнера.`

**6. Какие виды доступа к элементам контейнера существуют? Привести примеры.**

`Произвольный доступ (random access): например, доступ по индексу в массиве или векторе.`
`Последовательный доступ (sequential access): например, перебор элементов с помощью итераторов в списке.`

**7. Что такое итератор?**

`Итератор - это объект, который позволяет перебирать элементы контейнера и предоставляет доступ к каждому элементу в коллекции.`

**8. Каким образом может быть реализован итератор?**

`Итератор может быть реализован как объект с методами для перемещения по контейнеру (например, используя инкрементацию и декрементацию) и получения доступа к элементам. Чтобы понимать границы контейнера, они могут прописываться в нем самом.`

**9. Каким образом можно организовать объединение контейнеров?**

`Объединение контейнеров может быть организовано с помощью создания нового контейнера, который включает в себя элементы исходных контейнеров, также можно сортировать контейнеры при объединении или брать одинаковые элементы только по одному экземпляру, или, вовсе, брать только элементы содержащиеся в обоих изначальных контейнерах. Все зависит от конкретного условия. Для организации удобно использовать перегрузку бинарных операторов.`

**10. Какой доступ к элементам предоставляет контейнер, состоящий из элементов «ключ-значение»?**

`Контейнер, состоящий из элементов «ключ-значение» (например, map), предоставляет доступ к элементам через ключ.`

**11. Как называется контейнер, в котором вставка и удаление элементов выполняется на одном конце контейнера?**

`Контейнер, в котором вставка и удаление элементов выполняется на одном конце, называется стек (stack).`

**12. Какой из объектов (a,b,c,d) является контейнером?**

- a. int mas = 10;
- b. int mas;
- c. struct {char name[30]; int age;} mas;
- d. int mas[100].

`Из предложенных объектов контейнером является d. int mas[100]; - это массив, который может содержать до 100 элементов типа int.`

**13. Какой из объектов (a,b,c,d) не является контейнером?**
- a. int a[] = {1,2,3,4,5};
- b. int mas[30];
- c. struct {char name[30]; int age;} mas[30];
- d. int mas.

`Объект, который не является контейнером: d. 4. int mas; - это объявление переменной без инициализации массива или структуры.`

**14. Контейнер реализован как динамический массив, в нем определена операция доступ по индексу. Каким будет доступ к элементам контейнера?**

`Если контейнер реализован как динамический массив с операцией доступа по индексу, то доступ к элементам будет произвольным.`

**15. Контейнер реализован как линейный список. Каким будет доступ к элементам контейнера?**

`Если контейнер реализован как линейный список, то доступ к элементам будет последовательным.`
